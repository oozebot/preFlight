///|/ Copyright (c) preFlight 2025+ oozeBot, LLC
///|/ Copyright (c) Prusa Research 2016 - 2023 Pavel Mikuš @Godrak, Vojtěch Bubník @bubnikv, Lukáš Hejl @hejllukas, Lukáš Matěna @lukasmatena
///|/ Copyright (c) Slic3r 2014 - 2015 Alessandro Ranellucci @alranel
///|/ Copyright (c) 2015 Maksim Derbasov @ntfshard
///|/
///|/ ported from lib/Slic3r/Layer.pm:
///|/ Copyright (c) Prusa Research 2016 - 2022 Vojtěch Bubník @bubnikv
///|/ Copyright (c) Slic3r 2011 - 2016 Alessandro Ranellucci @alranel
///|/
///|/ preFlight is based on PrusaSlicer and released under AGPLv3 or higher
///|/
#ifndef slic3r_Layer_hpp_
#define slic3r_Layer_hpp_

#include <boost/container/small_vector.hpp>
#include <stddef.h>
#include <stdint.h>
#include <algorithm>
#include <functional>
#include <limits>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>
#include <cinttypes>
#include <cstddef>

#include "Line.hpp"
#include "libslic3r.h"
#include "BoundingBox.hpp"
#include "Flow.hpp"
#include "SurfaceCollection.hpp"
#include "ExtrusionEntityCollection.hpp"
#include "LayerRegion.hpp"
#include "libslic3r/ExPolygon.hpp"
#include "libslic3r/Polyline.hpp"
#include "ClipperUtils.hpp"
#include "Polygon.hpp" // For make_circle in circle-based visibility check

// Hash function for ExtrusionRole to use in unordered_map
namespace std
{
template<>
struct hash<Slic3r::ExtrusionRole>
{
    std::size_t operator()(const Slic3r::ExtrusionRole &role) const noexcept
    {
        // Access the underlying bitmask value via reinterpret_cast
        // ExtrusionRole inherits from enum_bitmask which stores m_bits as the only member
        return std::hash<uint16_t>{}(*reinterpret_cast<const uint16_t *>(&role));
    }
};
} // namespace std

namespace Slic3r
{

class ExPolygon;

using ExPolygons = std::vector<ExPolygon>;
class Layer;

using LayerPtrs = std::vector<Layer *>;
class LayerRegion;

using LayerRegionPtrs = std::vector<LayerRegion *>;
class PrintRegion;
class PrintObject;

namespace FillAdaptive
{
struct Octree;
}

namespace FillLightning
{
class Generator;
};

// Range of extrusions, referencing the source region by an index.
class LayerExtrusionRange : public ExtrusionRange
{
public:
    LayerExtrusionRange(uint32_t iregion, ExtrusionRange extrusion_range)
        : m_region(iregion), ExtrusionRange(extrusion_range)
    {
    }
    LayerExtrusionRange() = default;

    // Index of LayerRegion in Layer.
    uint32_t region() const { return m_region; };

private:
    // Index of LayerRegion in Layer.
    uint32_t m_region{0};
};

// One LayerIsland may be filled with solid fill, sparse fill, top / bottom fill.
static constexpr const size_t LayerExtrusionRangesStaticSize = 3;
using LayerExtrusionRanges =
#ifdef NDEBUG
    // To reduce memory allocation in release mode.
    boost::container::small_vector<LayerExtrusionRange, LayerExtrusionRangesStaticSize>;
#else  // NDEBUG
    // To ease debugging.
    std::vector<LayerExtrusionRange>;
#endif // NDEBUG

// LayerSlice contains one or more LayerIsland objects,
// each LayerIsland containing a set of perimeter extrusions extruded with one particular PrintRegionConfig parameters
// and one or multiple
struct LayerIsland
{
private:
    friend class Layer;
    static constexpr const uint32_t fill_region_composite_id = std::numeric_limits<uint32_t>::max();

public:
    // Boundary of the LayerIsland before perimeter generation.
    ExPolygon boundary;
    // Perimeter extrusions in LayerRegion belonging to this island.
    LayerExtrusionRange perimeters;
    // Thin fills of the same region as perimeters. Generated by classic perimeter generator, while Arachne puts them into perimeters.
    ExtrusionRange thin_fills;
    // Infill + gapfill extrusions in LayerRegion belonging to this island.
    LayerExtrusionRanges fills;
    // Region that is to be filled with the fills above (thin fills, regular fills).
    // Pointing to either LayerRegion::fill_expolygons() or LayerRegion::fill_expolygons_composite()
    // based on this->fill_expolygons_composite() flag.
    ExPolygonRange fill_expolygons;
    // Index of LayerRegion with LayerRegion::fill_expolygons() if not fill_expolygons_composite().
    uint32_t fill_region_id;
    bool fill_expolygons_composite() const { return this->fill_region_id == fill_region_composite_id; }
    // Centroid of this island used for path planning.
    //    Point                 centroid;

    bool has_extrusions() const { return !this->perimeters.empty() || !this->fills.empty(); }

    void add_fill_range(const LayerExtrusionRange &new_fill_range)
    {
        // Compress ranges.
        if (!this->fills.empty() && this->fills.back().region() == new_fill_range.region() &&
            *this->fills.back().end() == *new_fill_range.begin())
            this->fills.back() = {new_fill_range.region(), {*this->fills.back().begin(), *new_fill_range.end()}};
        else
            this->fills.push_back(new_fill_range);
    }
};

static constexpr const size_t LayerIslandsStaticSize = 1;
using LayerIslands =
#ifdef NDEBUG
    // To reduce memory allocation in release mode.
    boost::container::small_vector<LayerIsland, LayerIslandsStaticSize>;
#else  // NDEBUG
    // To ease debugging.
    std::vector<LayerIsland>;
#endif // NDEBUG

// One connected island of a layer. LayerSlice may consist of one or more LayerIslands.
struct LayerSlice
{
    struct Link
    {
        int32_t slice_idx;
        float area;
    };
    static constexpr const size_t LinksStaticSize = 4;
    using Links =
#ifdef NDEBUG
        // To reduce memory allocation in release mode.
        boost::container::small_vector<Link, LinksStaticSize>;
#else  // NDEBUG
       // To ease debugging.
        std::vector<Link>;
#endif // NDEBUG

    BoundingBox bbox;
    Links overlaps_above;
    Links overlaps_below;
    // One island for each region or region set that generates its own perimeters.
    // For multi-material prints or prints with regions of different perimeter parameters,
    // a LayerSlice may be split into multiple LayerIslands.
    // For most prints there will be just one island.
    LayerIslands islands;

    bool has_extrusions() const
    {
        for (const LayerIsland &island : islands)
            if (island.has_extrusions())
                return true;
        return false;
    }
};

using LayerSlices = std::vector<LayerSlice>;

class Layer
{
public:
    // Sequential index of this layer in PrintObject::m_layers, offsetted by the number of raft layers.
    size_t id() const { return m_id; }
    void set_id(size_t id) { m_id = id; }
    PrintObject *object() { return m_object; }
    const PrintObject *object() const { return m_object; }

    Layer *upper_layer;
    Layer *lower_layer;
    //    bool                slicing_errors;
    coordf_t slice_z; // Z used for slicing in unscaled coordinates
    coordf_t print_z; // Z used for printing in unscaled coordinates
    coordf_t height;  // layer height in unscaled coordinates
    coordf_t bottom_z() const { return this->print_z - this->height; }

    //Extrusions estimated to be seriously malformed, estimated during "Estimating curled extrusions" step. These lines should be avoided during fast travels.
    CurledLines curled_lines;

    // Collection of expolygons generated by slicing the possibly multiple meshes of the source geometry
    // (with possibly differing extruder ID and slicing parameters) and merged.
    // For the first layer, if the Elephant foot compensation is applied, this lslice is uncompensated, therefore
    // it includes the Elephant foot effect, thus it corresponds to the shape of the printed 1st layer.
    // These lslices aka islands are chained by the shortest traverse distance and this traversal
    // order will be applied by the G-code generator to the extrusions fitting into these lslices.
    // These lslices are also used to detect overhangs and overlaps between successive layers, therefore it is important
    // that the 1st lslice is not compensated by the Elephant foot compensation algorithm.
    ExPolygons lslices;
    // When fuzzy skin is painted on an object, store the painted areas here. These are used in
    // make_perimeters() to create PerimeterRegions that apply fuzzy skin selectively to perimeters
    // WITHOUT modifying the underlying slice geometry (no "geometry theft").
    ExPolygons fuzzy_skin_painted_areas;
    std::vector<size_t> lslice_indices_sorted_by_print_order;
    LayerSlices lslices_ex;

    size_t region_count() const { return m_regions.size(); }
    const LayerRegion *get_region(int idx) const { return m_regions[idx]; }
    LayerRegion *get_region(int idx) { return m_regions[idx]; }
    LayerRegion *add_region(const PrintRegion *print_region);
    const LayerRegionPtrs &regions() const { return m_regions; }
    // Test whether whether there are any slices assigned to this layer.
    bool empty() const;
    void make_slices();
    // After creating the slices on all layers, chain the islands overlapping in Z.
    static void build_up_down_graph(Layer &below, Layer &above);
    // Backup and restore raw sliced regions if needed.
    //FIXME Review whether not to simplify the code by keeping the raw_slices all the time.
    void backup_untyped_slices();
    void restore_untyped_slices();
    // To improve robustness of detect_surfaces_type() when reslicing (working with typed slices), see GH issue #7442.
    void restore_untyped_slices_no_extra_perimeters();
    // Slices merged into islands, to be used by the elephant foot compensation to trim the individual surfaces with the shrunk merged slices.
    ExPolygons merged(float offset) const;
    template<class T>
    bool any_internal_region_slice_contains(const T &item) const
    {
        for (const LayerRegion *layerm : m_regions)
            if (layerm->slices().any_internal_contains(item))
                return true;
        return false;
    }
    template<class T>
    bool any_bottom_region_slice_contains(const T &item) const
    {
        for (const LayerRegion *layerm : m_regions)
            if (layerm->slices().any_bottom_contains(item))
                return true;
        return false;
    }

    // Returns how many layers until this geometry becomes a top surface (visible from above)
    // Returns 0 if already at top surface (no material above)
    // Uses diff_ex() with safety offset to compute top surface regions, matching the algorithm
    // used by detect_surfaces_type(). This handles filleted corners and complex geometry correctly.
    // max_layers: Limit search depth for performance. Returns max_layers + 1 if not visible within range.
    //             Default INT_MAX searches all layers (original behavior).
    // Usage: layers_until_visible_from_top(pt, 3) - returns 0-3 if visible within 3 layers, else 4
    int layers_until_visible_from_top(const Point &pt, int max_layers = INT_MAX) const
    {
        // If no layer above, we're at the very top
        if (!this->upper_layer)
        {
            return 0;
        }

        // Compute top surface regions using diff_ex (same algorithm as detect_surfaces_type)
        // Top surfaces = areas on this layer that are NOT covered by the layer above
        ExPolygons top_surfaces = diff_ex(this->lslices, this->upper_layer->lslices, ApplySafetyOffset::Yes);

        // Check if point is inside any top surface region
        for (const ExPolygon &top : top_surfaces)
        {
            if (top.contains(pt))
            {
                return 0; // Point IS on a top surface - visible from top immediately
            }
        }

        // Point is not on a top surface at this layer.
        // Check subsequent layers to find when it becomes a top surface.
        int layers_to_top = 1;
        const Layer *current_layer = this->upper_layer;

        while (current_layer != nullptr)
        {
            // Early termination: stop if we've exceeded max_layers
            if (layers_to_top >= max_layers)
            {
                return max_layers + 1; // Not visible within range
            }

            // If no layer above current, current layer's entire surface is "top"
            if (!current_layer->upper_layer)
            {
                // Check if point is within this layer's geometry at all
                for (const ExPolygon &poly : current_layer->lslices)
                {
                    if (poly.contains(pt))
                    {
                        return layers_to_top;
                    }
                }
                // Point not in this layer - keep going (shouldn't happen normally)
                break;
            }

            // Compute top surfaces at current_layer
            ExPolygons layer_top_surfaces = diff_ex(current_layer->lslices, current_layer->upper_layer->lslices,
                                                    ApplySafetyOffset::Yes);

            // Check if point is inside any top surface region at this layer
            for (const ExPolygon &top : layer_top_surfaces)
            {
                if (top.contains(pt))
                {
                    return layers_to_top;
                }
            }

            layers_to_top++;
            current_layer = current_layer->upper_layer;
        }

        // Covered all the way to the top of the object (or point not found in any layer)
        return (layers_to_top > max_layers) ? max_layers + 1 : layers_to_top;
    }

    // For polygons/regions - check the centroid or multiple sample points
    int layers_until_visible_from_top(const ExPolygon &region, int max_layers = INT_MAX) const
    {
        // Use the centroid of the region as representative point
        Point centroid = region.contour.centroid();
        return layers_until_visible_from_top(centroid, max_layers);
    }

    // For polylines (like gap fills or perimeter segments)
    int layers_until_visible_from_top(const Polyline &polyline, int max_layers = INT_MAX) const
    {
        if (polyline.empty())
            return 0;

        // Check the midpoint of the polyline
        Point check_point = polyline.points.size() > 1 ? polyline.points[polyline.points.size() / 2]
                                                       : polyline.points.front();

        return layers_until_visible_from_top(check_point, max_layers);
    }

    // Convenience: Is this visible at the current layer?
    bool is_visible_from_top(const Point &pt) const { return layers_until_visible_from_top(pt, 1) == 0; }

    bool is_visible_from_top(const ExPolygon &region) const { return layers_until_visible_from_top(region, 1) == 0; }

    // Enhanced visibility check using 13 sample points around the check area.
    // Returns true ONLY if ALL 13 points are clear of the layer above.
    // This filters out thin exposed edges (fillets/tapers) while correctly detecting
    // true top surfaces (flat tops). Uses point containment checks with bounding box
    // pre-filtering for optimal performance.
    //
    // Logic: If ANY of the 13 sample points (center + 12 around perimeter at 30° intervals)
    // is covered by the layer above, this is NOT a true top surface.
    //
    // check_diameter: Diameter of the check area in scaled coordinates (use scaled(2.0) for 2mm)
    bool is_visible_from_top(const Point &pt, coord_t check_diameter) const
    {
        // If no layer above, we're at the very top
        if (!this->upper_layer)
        {
            return true;
        }

        const coord_t radius = check_diameter / 2;

        // Precomputed multipliers for 12 points around circle at 30° intervals
        // cos/sin values for 0°, 30°, 60°, 90°, 120°, 150°, 180°, 210°, 240°, 270°, 300°, 330°
        static const double cos_table[12] = {1.0,  0.866025,  0.5,  0.0, -0.5, -0.866025,
                                             -1.0, -0.866025, -0.5, 0.0, 0.5,  0.866025};
        static const double sin_table[12] = {0.0, 0.5,  0.866025,  1.0,  0.866025,  0.5,
                                             0.0, -0.5, -0.866025, -1.0, -0.866025, -0.5};

        // Bounding box of our 13 check points for fast pre-filtering
        const BoundingBox check_bbox(Point(pt.x() - radius, pt.y() - radius), Point(pt.x() + radius, pt.y() + radius));

        // Check all 13 points against upper layer geometry
        for (const ExPolygon &upper : this->upper_layer->lslices)
        {
            // Fast bounding box pre-check - skip ExPolygons that can't contain any of our points
            if (!check_bbox.overlap(get_extents(upper)))
                continue;

            // Check center point first (point 1 of 13)
            if (upper.contains(pt))
            {
                return false; // Center is inside upper layer = not visible
            }

            // Check 12 perimeter points (points 2-13)
            for (int i = 0; i < 12; ++i)
            {
                Point check_pt(pt.x() + coord_t(cos_table[i] * radius), pt.y() + coord_t(sin_table[i] * radius));
                if (upper.contains(check_pt))
                {
                    return false; // Perimeter point inside upper layer = not visible
                }
            }
        }

        // All 13 points are clear of the layer above -> TRUE top surface
        return true;
    }

    // Checks both top and bottom visibility in a single call, avoiding redundant function call overhead.
    // Uses 13-point sampling with bounding box pre-filtering for optimal performance.
    // Results are cached to avoid redundant computation when both fuzzy skin and top surface flow
    // need visibility info for the same points.
    // Parameters:
    //   pt: Point to check
    //   check_diameter: Diameter for top visibility check area (scaled coordinates)
    //   check_top: Whether to check top visibility
    //   check_bottom: Whether to check bottom visibility
    // Returns: true if point is visible from top OR bottom (based on which checks are enabled)
    bool is_visible_from_top_or_bottom(const Point &pt, coord_t check_diameter, bool check_top, bool check_bottom) const
    {
        // Only cache the common case: check_top=true, check_bottom=false (used by fuzzy skin and flow reduction)
        if (check_top && !check_bottom)
        {
            VisibilityCacheKey key{pt.x(), pt.y(), check_diameter};
            auto it = m_visibility_cache.find(key);
            if (it != m_visibility_cache.end())
            {
                return it->second; // Cache hit
            }
            // Cache miss - compute and store
            bool result = is_visible_from_top_uncached(pt, check_diameter);
            m_visibility_cache[key] = result;
            return result;
        }

        // Non-cached path for other combinations
        if (check_top && is_visible_from_top_uncached(pt, check_diameter))
        {
            return true;
        }
        if (check_bottom && is_visible_from_bottom(pt))
        {
            return true;
        }
        return false;
    }

    bool is_visible_from_top_uncached(const Point &pt, coord_t check_diameter) const
    {
        // Precomputed multipliers for 12 points around circle at 30° intervals
        static const double cos_table[12] = {1.0,  0.866025,  0.5,  0.0, -0.5, -0.866025,
                                             -1.0, -0.866025, -0.5, 0.0, 0.5,  0.866025};
        static const double sin_table[12] = {0.0, 0.5,  0.866025,  1.0,  0.866025,  0.5,
                                             0.0, -0.5, -0.866025, -1.0, -0.866025, -0.5};

        if (!this->upper_layer)
        {
            return true; // No layer above = visible from top
        }

        const coord_t radius = check_diameter / 2;
        bool all_clear = true;

        // Bounding box of our 13 check points for fast pre-filtering
        const BoundingBox check_bbox(Point(pt.x() - radius, pt.y() - radius), Point(pt.x() + radius, pt.y() + radius));

        // Check all 13 points against upper layer geometry
        for (const ExPolygon &upper : this->upper_layer->lslices)
        {
            // Fast bounding box pre-check - skip ExPolygons that can't contain any of our points
            if (!check_bbox.overlap(get_extents(upper)))
                continue;

            // Check center point first (point 1 of 13)
            if (upper.contains(pt))
            {
                all_clear = false;
                break;
            }

            // Check 12 perimeter points (points 2-13)
            for (int i = 0; i < 12 && all_clear; ++i)
            {
                Point check_pt(pt.x() + coord_t(cos_table[i] * radius), pt.y() + coord_t(sin_table[i] * radius));
                if (upper.contains(check_pt))
                {
                    all_clear = false;
                }
            }
            if (!all_clear)
                break;
        }

        return all_clear;
    }

    // Will this be visible within N layers? (uses early termination for performance)
    bool will_be_visible_within_n_layers(const Point &pt, int n_layers) const
    {
        return layers_until_visible_from_top(pt, n_layers) <= n_layers;
    }

    // Uses diff_ex() with safety offset to compute bottom surface regions, matching the algorithm
    // used by detect_surfaces_type(). This handles complex geometry correctly.
    // Returns how many layers until this geometry becomes a bottom surface (visible from below)
    // Returns 0 if already at bottom surface (no material below)
    // max_layers: Limit search depth for performance. Returns max_layers + 1 if not visible within range.
    //             Default INT_MAX searches all layers (original behavior).
    // Usage: layers_until_visible_from_bottom(pt, 3) - returns 0-3 if visible within 3 layers, else 4
    int layers_until_visible_from_bottom(const Point &pt, int max_layers = INT_MAX) const
    {
        // If no layer below, we're at the very bottom
        if (!this->lower_layer)
        {
            return 0;
        }

        // Compute bottom surface regions using diff_ex (same algorithm as detect_surfaces_type)
        // Bottom surfaces = areas on this layer that are NOT covered by the layer below
        ExPolygons bottom_surfaces = diff_ex(this->lslices, this->lower_layer->lslices, ApplySafetyOffset::Yes);

        // Check if point is inside any bottom surface region
        for (const ExPolygon &bottom : bottom_surfaces)
        {
            if (bottom.contains(pt))
            {
                return 0; // Point IS on a bottom surface - visible from bottom immediately
            }
        }

        // Point is not on a bottom surface at this layer.
        // Check previous layers to find when it becomes a bottom surface.
        int layers_to_bottom = 1;
        const Layer *current_layer = this->lower_layer;

        while (current_layer != nullptr)
        {
            // Early termination: stop if we've exceeded max_layers
            if (layers_to_bottom >= max_layers)
            {
                return max_layers + 1; // Not visible within range
            }

            // If no layer below current, current layer's entire surface is "bottom"
            if (!current_layer->lower_layer)
            {
                // Check if point is within this layer's geometry at all
                for (const ExPolygon &poly : current_layer->lslices)
                {
                    if (poly.contains(pt))
                    {
                        return layers_to_bottom;
                    }
                }
                // Point not in this layer - keep going (shouldn't happen normally)
                break;
            }

            // Compute bottom surfaces at current_layer
            ExPolygons layer_bottom_surfaces = diff_ex(current_layer->lslices, current_layer->lower_layer->lslices,
                                                       ApplySafetyOffset::Yes);

            // Check if point is inside any bottom surface region at this layer
            for (const ExPolygon &bottom : layer_bottom_surfaces)
            {
                if (bottom.contains(pt))
                {
                    return layers_to_bottom;
                }
            }

            layers_to_bottom++;
            current_layer = current_layer->lower_layer;
        }

        // Covered all the way to the bottom of the object (or point not found in any layer)
        return (layers_to_bottom > max_layers) ? max_layers + 1 : layers_to_bottom;
    }

    // For polygons/regions - check the centroid
    int layers_until_visible_from_bottom(const ExPolygon &region, int max_layers = INT_MAX) const
    {
        // Use the centroid of the region as representative point
        Point centroid = region.contour.centroid();
        return layers_until_visible_from_bottom(centroid, max_layers);
    }

    // For polylines
    int layers_until_visible_from_bottom(const Polyline &polyline, int max_layers = INT_MAX) const
    {
        if (polyline.empty())
            return 0;

        // Check the midpoint of the polyline
        Point check_point = polyline.points.size() > 1 ? polyline.points[polyline.points.size() / 2]
                                                       : polyline.points.front();

        return layers_until_visible_from_bottom(check_point, max_layers);
    }

    // Convenience: Is this visible at the current layer from below?
    bool is_visible_from_bottom(const Point &pt) const { return layers_until_visible_from_bottom(pt, 1) == 0; }

    bool is_visible_from_bottom(const ExPolygon &region) const
    {
        return layers_until_visible_from_bottom(region, 1) == 0;
    }

    // Will this be visible within N layers from below? (uses early termination for performance)
    bool will_be_visible_within_n_layers_from_bottom(const Point &pt, int n_layers) const
    {
        return layers_until_visible_from_bottom(pt, n_layers) <= n_layers;
    }

    // ============================================================================
    // DOWNWARD QUERIES (What's below)
    // ============================================================================

    // Get the extrusion role directly below this point (1 layer down)
    // Returns ExtrusionRole::None if nothing below or no lower layer
    ExtrusionRole role_below(const Point &pt) const;

    // Check if specific role exists directly below this point
    bool has_role_below(const Point &pt, ExtrusionRole role) const;

    // ============================================================================
    // UPWARD QUERIES (What's above)
    // ============================================================================

    // Get the extrusion role directly above this point (1 layer up)
    // Returns ExtrusionRole::None if nothing above or no upper layer
    ExtrusionRole role_above(const Point &pt) const;

    // ============================================================================
    // SEGMENT ANALYSIS (For splitting paths)
    // ============================================================================

    // Analyze a polyline/segment and return split points where role below changes
    // Returns pairs of: (split_point, role_below_after_split)
    // Empty vector means uniform role along entire segment
    std::vector<std::pair<Point, ExtrusionRole>> analyze_role_transitions_below(const Polyline &segment) const;

    // Check if role is uniform along entire segment
    // If true, out_role contains the uniform role
    // Returns false if segment crosses multiple roles or has no lower layer
    bool has_uniform_role_below(const Polyline &segment, ExtrusionRole &out_role) const;

    // ============================================================================
    // UTILITY - Get percentage of segment with specific role below
    // ============================================================================

    // Returns 0.0-1.0 representing fraction of segment length with target role below
    double segment_fraction_with_role_below(const Polyline &segment, ExtrusionRole target_role) const;

    // Query what role exists below a polyline using area-based detection
    // More accurate than point queries for wide beads over narrow infill
    ExtrusionRole role_below_for_polyline(const Polyline &polyline, float width) const;

    // RoleIndex structure for fast spatial lookup of extrusion roles
    struct RoleIndex
    {
        // Map from ExtrusionRole to polygons where that role exists
        // Use unordered_map since ExtrusionRole doesn't have operator<
        std::unordered_map<ExtrusionRole, ExPolygons> role_regions;

        // Unlike role_regions[InterlockingPerimeter] which contains individual bead polygons,
        // this is a merged/filled zone that treats gaps between beads as "inside".
        // Used for accurate boundary crossing detection without false positives at bead gaps.
        ExPolygons interlocking_zone;
        bool has_interlocking_zone() const { return !interlocking_zone.empty(); }

        // Search radius for expanded point queries (2.5x perimeter width)
        // Needed for interlocking perimeters which have gaps from -100% overlap
        coord_t search_radius = scale_(1.0); // Default 1mm, calculated in build_from_layer

        // Overall bounding box of all solid infill regions
        BoundingBox m_solid_infill_bbox;

        // Grid-based spatial index for fine-grained filtering
        static constexpr int GRID_SIZE = 20; // 20x20 grid (400 cells)
        struct GridCell
        {
            bool has_solid_infill = false;
        };
        std::vector<GridCell> m_solid_infill_grid; // GRID_SIZE * GRID_SIZE cells
        coord_t m_grid_cell_size_x = 0;
        coord_t m_grid_cell_size_y = 0;

        // Check if layer has any solid infill
        bool has_solid_infill() const { return m_solid_infill_bbox.defined; }

        // If a layer has no sparse infill at all, then ALL segments above it are over solid
        // Returns true if the layer has zero sparse infill regions
        bool has_sparse_infill = false; // Set during build_from_layer
        bool is_fully_solid() const { return has_solid_infill() && !has_sparse_infill; }

        // Grid-based check if a segment might overlap solid infill
        // Returns true if ANY grid cell overlapping the segment contains solid
        bool segment_might_overlap_solid(const BoundingBox &segment_bbox) const;

        // Ultra-fast check if a point is over solid infill using existing grid infrastructure
        // Returns true if point overlaps any solid infill region
        bool is_over_solid_infill(const Point &pt) const;

        // Helper: Get grid cell indices for a bounding box
        void get_grid_cells_for_bbox(const BoundingBox &bbox, int &min_x, int &max_x, int &min_y, int &max_y) const;

        // Build from layer's extrusions
        void build_from_layer(const Layer *layer);
        // Recursively collect role from extrusion entity
        void collect_role_from_entity(const ExtrusionEntity *entity);
        // Add an extrusion path's area to its role's regions
        void add_path_to_role(const ExtrusionPath &path);
        // Query what role exists at a point
        ExtrusionRole query_role_at_point(const Point &pt) const;
        // Query what role exists along a polyline path (area-based detection)
        ExtrusionRole query_role_for_polyline(const Polyline &polyline, float width) const;
    };

    // Build role index on first access (lazy initialization)
    // Used by GCode generation for spatial queries
    const RoleIndex &get_role_index_for_layer(const Layer *layer) const;

    void make_perimeters();
    void make_fills(FillAdaptive::Octree *adaptive_fill_octree, FillAdaptive::Octree *support_fill_octree,
                    FillLightning::Generator *lightning_generator);
    Polylines generate_sparse_infill_polylines_for_anchoring(FillAdaptive::Octree *adaptive_fill_octree,
                                                             FillAdaptive::Octree *support_fill_octree,
                                                             FillLightning::Generator *lightning_generator) const;
    void make_ironing();

    void export_region_slices_to_svg(const char *path) const;
    void export_region_fill_surfaces_to_svg(const char *path) const;
    // Export to "out/LayerRegion-name-%d.svg" with an increasing index with every export.
    void export_region_slices_to_svg_debug(const char *name) const;
    void export_region_fill_surfaces_to_svg_debug(const char *name) const;

    // Is there any valid extrusion assigned to this LayerRegion?
    virtual bool has_extrusions() const
    {
        for (auto layerm : m_regions)
            if (layerm->has_extrusions())
                return true;
        return false;
    }
    //    virtual bool            has_extrusions() const { for (const LayerSlice &lslice : lslices_ex) if (lslice.has_extrusions()) return true; return false; }

protected:
    friend class PrintObject;
    friend std::vector<Layer *> new_layers(PrintObject *, const std::vector<coordf_t> &);
    friend std::string fix_slicing_errors(LayerPtrs &, const std::function<void()> &);

    Layer(size_t id, PrintObject *object, coordf_t height, coordf_t print_z, coordf_t slice_z)
        : upper_layer(nullptr)
        , lower_layer(nullptr)
        ,
        //slicing_errors(false),
        slice_z(slice_z)
        , print_z(print_z)
        , height(height)
        , m_id(id)
        , m_object(object)
    {
    }
    virtual ~Layer();
    // Clear fill extrusions, remove them from layer islands.
    void clear_fills();

private:
    mutable std::unique_ptr<RoleIndex> m_role_index_below;
    mutable std::unique_ptr<RoleIndex> m_role_index_above;

    // Clear cached indexes (called if layer is modified)
    void invalidate_role_indexes() const;

    // Used by both fuzzy skin and top surface flow reduction to avoid duplicate visibility lookups.
    // Key: (point.x, point.y, check_diameter) packed into a struct for hashing.
    struct VisibilityCacheKey
    {
        coord_t x, y, diameter;
        bool operator==(const VisibilityCacheKey &other) const
        {
            return x == other.x && y == other.y && diameter == other.diameter;
        }
    };
    struct VisibilityCacheHash
    {
        size_t operator()(const VisibilityCacheKey &k) const
        {
            // Simple hash combining x, y, diameter
            return std::hash<coord_t>()(k.x) ^ (std::hash<coord_t>()(k.y) << 1) ^
                   (std::hash<coord_t>()(k.diameter) << 2);
        }
    };
    mutable std::unordered_map<VisibilityCacheKey, bool, VisibilityCacheHash> m_visibility_cache;

public:
    // Clear visibility cache - call after processing each layer to free memory
    void clear_visibility_cache() const { m_visibility_cache.clear(); }

private:
    void sort_perimeters_into_islands(
        // Slices for which perimeters and fill_expolygons were just created.
        // The slices may have been created by merging multiple source slices with the same perimeter parameters.
        const SurfaceCollection &slices,
        // Region where the perimeters, gap fills and fill expolygons are stored.
        const uint32_t region_id,
        // Perimeters and gap fills produced by the perimeter generator for the slices,
        // sorted by the source slices.
        const std::vector<std::pair<ExtrusionRange, ExtrusionRange>> &perimeter_and_gapfill_ranges,
        // Fill expolygons produced for all source slices above.
        ExPolygons &&fill_expolygons,
        // Fill expolygon ranges sorted by the source slices.
        const std::vector<ExPolygonRange> &fill_expolygons_ranges,
        // If the current layer consists of multiple regions, then the fill_expolygons above are split by the source LayerRegion surfaces.
        const std::vector<uint32_t> &layer_region_ids);

    // Sequential index of layer, 0-based, offsetted by number of raft layers.
    size_t m_id;
    PrintObject *m_object;
    LayerRegionPtrs m_regions;
};

class SupportLayer : public Layer
{
public:
    // Polygons covered by the supports: base, interface and contact areas.
    // Used to suppress retraction if moving for a support extrusion over these support_islands.
    ExPolygons support_islands;
    // Slightly inflated bounding boxes of the above, for faster intersection query.
    BoundingBoxes support_islands_bboxes;
    // Extrusion paths for the support base and for the support interface and contacts.
    ExtrusionEntityCollection support_fills;

    // Is there any valid extrusion assigned to this LayerRegion?
    virtual bool has_extrusions() const { return !support_fills.empty(); }

    // Zero based index of an interface layer, used for alternating direction of interface / contact layers.
    size_t interface_id() const { return m_interface_id; }

protected:
    friend class PrintObject;

    // The constructor has been made public to be able to insert additional support layers for the skirt or a wipe tower
    // between the raft and the object first layer.
    SupportLayer(size_t id, size_t interface_id, PrintObject *object, coordf_t height, coordf_t print_z,
                 coordf_t slice_z)
        : Layer(id, object, height, print_z, slice_z), m_interface_id(interface_id)
    {
    }
    virtual ~SupportLayer() = default;

    size_t m_interface_id;
};

template<typename LayerContainer>
inline std::vector<float> zs_from_layers(const LayerContainer &layers)
{
    std::vector<float> zs;
    zs.reserve(layers.size());
    for (const Layer *l : layers)
        zs.emplace_back((float) l->slice_z);
    return zs;
}

extern BoundingBox get_extents(const LayerRegion &layer_region);
extern BoundingBox get_extents(const LayerRegionPtrs &layer_regions);

} // namespace Slic3r

#endif
